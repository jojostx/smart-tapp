
    public static function cacheableDatabaseQuery(?bool $use_auth_id = true): static
    {
        dd(static::query());

        if (Cache::has(static::cacheKey($use_auth_id))) {
            // check cache first
            // is value present?
            // Yes: retrieve from cache
            // No: retrieve from database
            return Cache::remember(static::cacheKey($use_auth_id), 15, function () {
                return static::query();
            });
        }

        return static::query();
    }

    public function cacheKey(?bool $use_auth_id = true): string
    {
        // if auth_id is passed in use it else try to resolve using auth()->id else set to empty string
        $auth_id = $use_auth_id ? auth()?->id() : '';

        // if auth_id has a value return eg: accesses/{auth_id}/1515650910
        // else return eg: accesses/1515650910
        return sprintf(
            "%s/%s%s",
            $this->getTable(),
            $auth_id . '/',
            $this->updated_at->timestamp
        );
    }

    if (method_exists(static::getModel(), 'driver') && method_exists(static::getModel(), 'vehicle')) {
        dd('hm',  $this->form->getLivewire()->data, $data);
    }

    {
        // I] after sending a notification, save the:
        //      1. message_id of the notification from the response of the network call to the API
        //      2. the response of the network call to the API
        //      3. the notification and notifiable 
        //      4. the tenant->id
        //      5. the admin user->id
        // to redis with proper tagging based on time period of 5 minutes interval.
        // ======================================================================

        // A - II] when delivery report returns from the API,
        // use the message_id from the request body to retrieve the metadata of the notification from redis
        // deliver the response the correct user in the correct tenant through webhook

        // B - II] 
        // after sending a notification, 
        // [] save the message_id from the response to the data column of the notification in the notifications table:[set the status to sending]
        // [âœ“] if network failure occurs, set the status of the notification to failed in the notifications table:
        // when delivery report returns from the API,
        //      [] use the message_id from the request body to retrieve and update the status of the notification to whatever status 
        //      [] in the response in the notification's table.
        // [] check the notifications table every 5 minutes to know if any sms activation notification has been updated
        // [] if so, dispatch a filament notification for each
    }

    {
        // issued - [Activate (default do not Send)], Deactivate, Send access activation notification
        // active - Deactivate, Send access activation notification
        // expired - Deactivate, [Issue (default Send), Activate (default do not Send)] -> Send access activation notification,
        // inactive|deactivated - [Issue (default Send), Activate (default Send)] -> shows modal for Send access activation notification confirmation
    }