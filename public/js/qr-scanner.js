/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/js/qr-scanner.js":
/*!************************************!*\
  !*** ./resources/js/qr-scanner.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var qr_scanner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! qr-scanner */ \"./node_modules/qr-scanner/qr-scanner.min.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\ndocument.addEventListener(\"alpine:init\", function () {\n  Alpine.data(\"qrcodeScanner\", function (_ref) {\n    var state = _ref.state;\n    return {\n      state: state,\n      /**\r\n       * @type {(QrScanner|null)} scanner\r\n       */\n      scanner: null,\n      canUseFlash: false,\n      error: null,\n      errorTimerId: null,\n      isScanning: false,\n      isProcessing: false,\n      get hasError() {\n        return Boolean(this.error);\n      },\n      get isFlashOn() {\n        var _this$scanner$isFlash, _this$scanner;\n        return (_this$scanner$isFlash = (_this$scanner = this.scanner) === null || _this$scanner === void 0 ? void 0 : _this$scanner.isFlashOn()) !== null && _this$scanner$isFlash !== void 0 ? _this$scanner$isFlash : false;\n      },\n      init: function () {\n        var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n          var _this = this;\n          return _regeneratorRuntime().wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  this.initScanner();\n                  this.$watch(\"isScanning\", function (n, o) {\n                    _this.errorTimerId && clearTimeout(_this.errorTimerId);\n                    if (n && !o) {\n                      _this.errorTimerId = setTimeout(function () {\n                        _this.displayError(\"Unable to detect QR code, please make sure to focus on the QR code to complete the scan\");\n                      }, 30000);\n                    }\n                  });\n                case 2:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this);\n        }));\n        function init() {\n          return _init.apply(this, arguments);\n        }\n        return init;\n      }(),\n      initScanner: function () {\n        var _initScanner = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n          var _this$scanner2,\n            _this2 = this;\n          return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  if (this.scanner && (_this$scanner2 = this.scanner) !== null && _this$scanner2 !== void 0 && _this$scanner2.destroy()) {\n                    this.scanner = null;\n                  }\n                  _context2.next = 3;\n                  return qr_scanner__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hasCamera();\n                case 3:\n                  if (_context2.sent) {\n                    _context2.next = 6;\n                    break;\n                  }\n                  this.displayError(\"Qr Code scanning is not supported on your device.\");\n                  return _context2.abrupt(\"return\");\n                case 6:\n                  this.scanner = new qr_scanner__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.$refs.qr_scanner, function (result) {\n                    return _this2.processResult(result);\n                  }, {\n                    onDecodeError: function onDecodeError(error) {\n                      _this2.error = error;\n                    },\n                    highlightScanRegion: true,\n                    highlightCodeOutline: true\n                  });\n                  this.scanner.setInversionMode(\"both\");\n                case 8:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, this);\n        }));\n        function initScanner() {\n          return _initScanner.apply(this, arguments);\n        }\n        return initScanner;\n      }(),\n      startScanning: function () {\n        var _startScanning = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n          return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  if (!(Boolean(this.scanner) == false)) {\n                    _context3.next = 2;\n                    break;\n                  }\n                  return _context3.abrupt(\"return\");\n                case 2:\n                  _context3.next = 4;\n                  return this.scanner.start();\n                case 4:\n                  this.isScanning = true;\n                  this.isProcessing = false;\n                  _context3.next = 8;\n                  return this.scanner.hasFlash();\n                case 8:\n                  this.canUseFlash = _context3.sent;\n                case 9:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3, this);\n        }));\n        function startScanning() {\n          return _startScanning.apply(this, arguments);\n        }\n        return startScanning;\n      }(),\n      stopScanning: function stopScanning() {\n        if (Boolean(this.scanner) == false) {\n          this.isScanning = false;\n          return;\n        }\n        this.scanner.stop();\n        this.isScanning = false;\n        this.error = null;\n      },\n      processResult: function processResult(result) {\n        // stop scanning\n        this.stopScanning();\n        // start processing\n        this.isProcessing = true;\n        // do something with the result, eg: pass to lw comp for validation\n        this.state = result.data;\n      },\n      toggleFlash: function () {\n        var _toggleFlash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n          return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  if (!this.canUseFlash) {\n                    _context4.next = 3;\n                    break;\n                  }\n                  _context4.next = 3;\n                  return this.scanner.toggleFlash();\n                case 3:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }\n          }, _callee4, this);\n        }));\n        function toggleFlash() {\n          return _toggleFlash.apply(this, arguments);\n        }\n        return toggleFlash;\n      }(),\n      displayError: function displayError(error) {\n        this.$dispatch(\"open-alert\", {\n          color: \"danger\",\n          message: error,\n          timeout: 10000\n        });\n      }\n    };\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvcXItc2Nhbm5lci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7K0NBQ0E7QUFBQTtBQUFBO0FBRG1DO0FBRW5DQyxRQUFRLENBQUNDLGdCQUFnQixDQUFDLGFBQWEsRUFBRSxZQUFNO0VBQzNDQyxNQUFNLENBQUNDLElBQUksQ0FBQyxlQUFlLEVBQUUsZ0JBQWU7SUFBQSxJQUFaQyxLQUFLLFFBQUxBLEtBQUs7SUFDakMsT0FBTztNQUNIQSxLQUFLLEVBQUxBLEtBQUs7TUFDTDtBQUNaO0FBQ0E7TUFDWUMsT0FBTyxFQUFFLElBQUk7TUFFYkMsV0FBVyxFQUFFLEtBQUs7TUFFbEJDLEtBQUssRUFBRSxJQUFJO01BRVhDLFlBQVksRUFBRSxJQUFJO01BRWxCQyxVQUFVLEVBQUUsS0FBSztNQUVqQkMsWUFBWSxFQUFFLEtBQUs7TUFFbkIsSUFBSUMsUUFBUSxHQUFHO1FBQ1gsT0FBT0MsT0FBTyxDQUFDLElBQUksQ0FBQ0wsS0FBSyxDQUFDO01BQzlCLENBQUM7TUFFRCxJQUFJTSxTQUFTLEdBQUc7UUFBQTtRQUNaLGlEQUFPLElBQUksQ0FBQ1IsT0FBTyxrREFBWixjQUFjUSxTQUFTLEVBQUUseUVBQUksS0FBSztNQUM3QyxDQUFDO01BRURDLElBQUk7UUFBQSx1RUFBRTtVQUFBO1VBQUE7WUFBQTtjQUFBO2dCQUFBO2tCQUNGLElBQUksQ0FBQ0MsV0FBVyxFQUFFO2tCQUVsQixJQUFJLENBQUNDLE1BQU0sQ0FBQyxZQUFZLEVBQUUsVUFBQ0MsQ0FBQyxFQUFFQyxDQUFDLEVBQUs7b0JBQ2hDLEtBQUksQ0FBQ1YsWUFBWSxJQUFJVyxZQUFZLENBQUMsS0FBSSxDQUFDWCxZQUFZLENBQUM7b0JBRXBELElBQUlTLENBQUMsSUFBSSxDQUFDQyxDQUFDLEVBQUU7c0JBQ1QsS0FBSSxDQUFDVixZQUFZLEdBQUdZLFVBQVUsQ0FBQyxZQUFNO3dCQUNqQyxLQUFJLENBQUNDLFlBQVksQ0FDYix5RkFBeUYsQ0FDNUY7c0JBQ0wsQ0FBQyxFQUFFLEtBQUssQ0FBQztvQkFDYjtrQkFDSixDQUFDLENBQUM7Z0JBQUM7Z0JBQUE7a0JBQUE7Y0FBQTtZQUFBO1VBQUE7UUFBQSxDQUNOO1FBQUE7VUFBQTtRQUFBO1FBQUE7TUFBQTtNQUVETixXQUFXO1FBQUEsOEVBQUU7VUFBQTtZQUFBO1VBQUE7WUFBQTtjQUFBO2dCQUFBO2tCQUNULElBQUksSUFBSSxDQUFDVixPQUFPLHNCQUFJLElBQUksQ0FBQ0EsT0FBTywyQ0FBWixlQUFjaUIsT0FBTyxFQUFFLEVBQUU7b0JBQ3pDLElBQUksQ0FBQ2pCLE9BQU8sR0FBRyxJQUFJO2tCQUN2QjtrQkFBQztrQkFBQSxPQUVXTiw0REFBbUIsRUFBRTtnQkFBQTtrQkFBQTtvQkFBQTtvQkFBQTtrQkFBQTtrQkFDN0IsSUFBSSxDQUFDc0IsWUFBWSxDQUNiLG1EQUFtRCxDQUN0RDtrQkFBQztnQkFBQTtrQkFLTixJQUFJLENBQUNoQixPQUFPLEdBQUcsSUFBSU4sa0RBQVMsQ0FDeEIsSUFBSSxDQUFDeUIsS0FBSyxDQUFDQyxVQUFVLEVBQ3JCLFVBQUNDLE1BQU07b0JBQUEsT0FBSyxNQUFJLENBQUNDLGFBQWEsQ0FBQ0QsTUFBTSxDQUFDO2tCQUFBLEdBQ3RDO29CQUNJRSxhQUFhLEVBQUUsdUJBQUNyQixLQUFLLEVBQUs7c0JBQ3RCLE1BQUksQ0FBQ0EsS0FBSyxHQUFHQSxLQUFLO29CQUN0QixDQUFDO29CQUNEc0IsbUJBQW1CLEVBQUUsSUFBSTtvQkFDekJDLG9CQUFvQixFQUFFO2tCQUMxQixDQUFDLENBQ0o7a0JBRUQsSUFBSSxDQUFDekIsT0FBTyxDQUFDMEIsZ0JBQWdCLENBQUMsTUFBTSxDQUFDO2dCQUFDO2dCQUFBO2tCQUFBO2NBQUE7WUFBQTtVQUFBO1FBQUEsQ0FDekM7UUFBQTtVQUFBO1FBQUE7UUFBQTtNQUFBO01BRURDLGFBQWE7UUFBQSxnRkFBRTtVQUFBO1lBQUE7Y0FBQTtnQkFBQTtrQkFBQSxNQUNQcEIsT0FBTyxDQUFDLElBQUksQ0FBQ1AsT0FBTyxDQUFDLElBQUksS0FBSztvQkFBQTtvQkFBQTtrQkFBQTtrQkFBQTtnQkFBQTtrQkFBQTtrQkFBQSxPQUk1QixJQUFJLENBQUNBLE9BQU8sQ0FBQzRCLEtBQUssRUFBRTtnQkFBQTtrQkFFMUIsSUFBSSxDQUFDeEIsVUFBVSxHQUFHLElBQUk7a0JBQ3RCLElBQUksQ0FBQ0MsWUFBWSxHQUFHLEtBQUs7a0JBQUM7a0JBQUEsT0FDRCxJQUFJLENBQUNMLE9BQU8sQ0FBQzZCLFFBQVEsRUFBRTtnQkFBQTtrQkFBaEQsSUFBSSxDQUFDNUIsV0FBVztnQkFBQTtnQkFBQTtrQkFBQTtjQUFBO1lBQUE7VUFBQTtRQUFBLENBQ25CO1FBQUE7VUFBQTtRQUFBO1FBQUE7TUFBQTtNQUVENkIsWUFBWSxFQUFFLHdCQUFZO1FBQ3RCLElBQUl2QixPQUFPLENBQUMsSUFBSSxDQUFDUCxPQUFPLENBQUMsSUFBSSxLQUFLLEVBQUU7VUFDaEMsSUFBSSxDQUFDSSxVQUFVLEdBQUcsS0FBSztVQUN2QjtRQUNKO1FBRUEsSUFBSSxDQUFDSixPQUFPLENBQUMrQixJQUFJLEVBQUU7UUFDbkIsSUFBSSxDQUFDM0IsVUFBVSxHQUFHLEtBQUs7UUFDdkIsSUFBSSxDQUFDRixLQUFLLEdBQUcsSUFBSTtNQUNyQixDQUFDO01BRURvQixhQUFhLEVBQUUsdUJBQVVELE1BQU0sRUFBRTtRQUM3QjtRQUNBLElBQUksQ0FBQ1MsWUFBWSxFQUFFO1FBQ25CO1FBQ0EsSUFBSSxDQUFDekIsWUFBWSxHQUFHLElBQUk7UUFDeEI7UUFDQSxJQUFJLENBQUNOLEtBQUssR0FBR3NCLE1BQU0sQ0FBQ3ZCLElBQUk7TUFDNUIsQ0FBQztNQUVEa0MsV0FBVztRQUFBLDhFQUFFO1VBQUE7WUFBQTtjQUFBO2dCQUFBO2tCQUFBLEtBQ0wsSUFBSSxDQUFDL0IsV0FBVztvQkFBQTtvQkFBQTtrQkFBQTtrQkFBQTtrQkFBQSxPQUNWLElBQUksQ0FBQ0QsT0FBTyxDQUFDZ0MsV0FBVyxFQUFFO2dCQUFBO2dCQUFBO2tCQUFBO2NBQUE7WUFBQTtVQUFBO1FBQUEsQ0FFdkM7UUFBQTtVQUFBO1FBQUE7UUFBQTtNQUFBO01BRURoQixZQUFZLEVBQUUsc0JBQVVkLEtBQUssRUFBRTtRQUMzQixJQUFJLENBQUMrQixTQUFTLENBQUMsWUFBWSxFQUFFO1VBQ3pCQyxLQUFLLEVBQUUsUUFBUTtVQUNmQyxPQUFPLEVBQUVqQyxLQUFLO1VBQ2RrQyxPQUFPLEVBQUU7UUFDYixDQUFDLENBQUM7TUFDTjtJQUNKLENBQUM7RUFDTCxDQUFDLENBQUM7QUFDTixDQUFDLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvcXItc2Nhbm5lci5qcz9hYWZjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBRclNjYW5uZXIgZnJvbSBcInFyLXNjYW5uZXJcIjtcclxuXHJcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJhbHBpbmU6aW5pdFwiLCAoKSA9PiB7XHJcbiAgICBBbHBpbmUuZGF0YShcInFyY29kZVNjYW5uZXJcIiwgKHsgc3RhdGUgfSkgPT4ge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHN0YXRlLFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQHR5cGUgeyhRclNjYW5uZXJ8bnVsbCl9IHNjYW5uZXJcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHNjYW5uZXI6IG51bGwsXHJcblxyXG4gICAgICAgICAgICBjYW5Vc2VGbGFzaDogZmFsc2UsXHJcblxyXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcclxuXHJcbiAgICAgICAgICAgIGVycm9yVGltZXJJZDogbnVsbCxcclxuXHJcbiAgICAgICAgICAgIGlzU2Nhbm5pbmc6IGZhbHNlLFxyXG5cclxuICAgICAgICAgICAgaXNQcm9jZXNzaW5nOiBmYWxzZSxcclxuXHJcbiAgICAgICAgICAgIGdldCBoYXNFcnJvcigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuZXJyb3IpO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgZ2V0IGlzRmxhc2hPbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5uZXI/LmlzRmxhc2hPbigpID8/IGZhbHNlO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgaW5pdDogYXN5bmMgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbml0U2Nhbm5lcigpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuJHdhdGNoKFwiaXNTY2FubmluZ1wiLCAobiwgbykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JUaW1lcklkICYmIGNsZWFyVGltZW91dCh0aGlzLmVycm9yVGltZXJJZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuICYmICFvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JUaW1lcklkID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlFcnJvcihcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlVuYWJsZSB0byBkZXRlY3QgUVIgY29kZSwgcGxlYXNlIG1ha2Ugc3VyZSB0byBmb2N1cyBvbiB0aGUgUVIgY29kZSB0byBjb21wbGV0ZSB0aGUgc2NhblwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAzMDAwMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBpbml0U2Nhbm5lcjogYXN5bmMgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lciAmJiB0aGlzLnNjYW5uZXI/LmRlc3Ryb3koKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nhbm5lciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCEoYXdhaXQgUXJTY2FubmVyLmhhc0NhbWVyYSgpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheUVycm9yKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlFyIENvZGUgc2Nhbm5pbmcgaXMgbm90IHN1cHBvcnRlZCBvbiB5b3VyIGRldmljZS5cIlxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjYW5uZXIgPSBuZXcgUXJTY2FubmVyKFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHJlZnMucXJfc2Nhbm5lcixcclxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0KSA9PiB0aGlzLnByb2Nlc3NSZXN1bHQocmVzdWx0KSxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRGVjb2RlRXJyb3I6IChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHRTY2FuUmVnaW9uOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHRDb2RlT3V0bGluZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5zZXRJbnZlcnNpb25Nb2RlKFwiYm90aFwiKTtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHN0YXJ0U2Nhbm5pbmc6IGFzeW5jIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChCb29sZWFuKHRoaXMuc2Nhbm5lcikgPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zY2FubmVyLnN0YXJ0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5pc1NjYW5uaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNQcm9jZXNzaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhblVzZUZsYXNoID0gYXdhaXQgdGhpcy5zY2FubmVyLmhhc0ZsYXNoKCk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBzdG9wU2Nhbm5pbmc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChCb29sZWFuKHRoaXMuc2Nhbm5lcikgPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzU2Nhbm5pbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5zY2FubmVyLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNTY2FubmluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IG51bGw7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBwcm9jZXNzUmVzdWx0OiBmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzdG9wIHNjYW5uaW5nXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BTY2FubmluZygpO1xyXG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgcHJvY2Vzc2luZ1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc1Byb2Nlc3NpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3VsdCwgZWc6IHBhc3MgdG8gbHcgY29tcCBmb3IgdmFsaWRhdGlvblxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHJlc3VsdC5kYXRhO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgdG9nZ2xlRmxhc2g6IGFzeW5jIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhblVzZUZsYXNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zY2FubmVyLnRvZ2dsZUZsYXNoKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBkaXNwbGF5RXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kZGlzcGF0Y2goXCJvcGVuLWFsZXJ0XCIsIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogXCJkYW5nZXJcIixcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvcixcclxuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0OiAxMDAwMCxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxufSk7XHJcbiJdLCJuYW1lcyI6WyJRclNjYW5uZXIiLCJkb2N1bWVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJBbHBpbmUiLCJkYXRhIiwic3RhdGUiLCJzY2FubmVyIiwiY2FuVXNlRmxhc2giLCJlcnJvciIsImVycm9yVGltZXJJZCIsImlzU2Nhbm5pbmciLCJpc1Byb2Nlc3NpbmciLCJoYXNFcnJvciIsIkJvb2xlYW4iLCJpc0ZsYXNoT24iLCJpbml0IiwiaW5pdFNjYW5uZXIiLCIkd2F0Y2giLCJuIiwibyIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJkaXNwbGF5RXJyb3IiLCJkZXN0cm95IiwiaGFzQ2FtZXJhIiwiJHJlZnMiLCJxcl9zY2FubmVyIiwicmVzdWx0IiwicHJvY2Vzc1Jlc3VsdCIsIm9uRGVjb2RlRXJyb3IiLCJoaWdobGlnaHRTY2FuUmVnaW9uIiwiaGlnaGxpZ2h0Q29kZU91dGxpbmUiLCJzZXRJbnZlcnNpb25Nb2RlIiwic3RhcnRTY2FubmluZyIsInN0YXJ0IiwiaGFzRmxhc2giLCJzdG9wU2Nhbm5pbmciLCJzdG9wIiwidG9nZ2xlRmxhc2giLCIkZGlzcGF0Y2giLCJjb2xvciIsIm1lc3NhZ2UiLCJ0aW1lb3V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/qr-scanner.js\n");

/***/ }),

/***/ "./node_modules/qr-scanner/qr-scanner.min.js":
/*!***************************************************!*\
  !*** ./node_modules/qr-scanner/qr-scanner.min.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nclass e{constructor(a,b,c,d,f){this._legacyCanvasSize=e.DEFAULT_CANVAS_SIZE;this._preferredCamera=\"environment\";this._maxScansPerSecond=25;this._lastScanTimestamp=-1;this._destroyed=this._flashOn=this._paused=this._active=!1;this.$video=a;this.$canvas=document.createElement(\"canvas\");c&&\"object\"===typeof c?this._onDecode=b:(c||d||f?console.warn(\"You're using a deprecated version of the QrScanner constructor which will be removed in the future\"):console.warn(\"Note that the type of the scan result passed to onDecode will change in the future. To already switch to the new api today, you can pass returnDetailedScanResult: true.\"),\nthis._legacyOnDecode=b);b=\"object\"===typeof c?c:{};this._onDecodeError=b.onDecodeError||(\"function\"===typeof c?c:this._onDecodeError);this._calculateScanRegion=b.calculateScanRegion||(\"function\"===typeof d?d:this._calculateScanRegion);this._preferredCamera=b.preferredCamera||f||this._preferredCamera;this._legacyCanvasSize=\"number\"===typeof c?c:\"number\"===typeof d?d:this._legacyCanvasSize;this._maxScansPerSecond=b.maxScansPerSecond||this._maxScansPerSecond;this._onPlay=this._onPlay.bind(this);this._onLoadedMetaData=\nthis._onLoadedMetaData.bind(this);this._onVisibilityChange=this._onVisibilityChange.bind(this);this._updateOverlay=this._updateOverlay.bind(this);a.disablePictureInPicture=!0;a.playsInline=!0;a.muted=!0;let h=!1;a.hidden&&(a.hidden=!1,h=!0);document.body.contains(a)||(document.body.appendChild(a),h=!0);c=a.parentElement;if(b.highlightScanRegion||b.highlightCodeOutline){d=!!b.overlay;this.$overlay=b.overlay||document.createElement(\"div\");f=this.$overlay.style;f.position=\"absolute\";f.display=\"none\";\nf.pointerEvents=\"none\";this.$overlay.classList.add(\"scan-region-highlight\");if(!d&&b.highlightScanRegion){this.$overlay.innerHTML='<svg class=\"scan-region-highlight-svg\" viewBox=\"0 0 238 238\" preserveAspectRatio=\"none\" style=\"position:absolute;width:100%;height:100%;left:0;top:0;fill:none;stroke:#e9b213;stroke-width:4;stroke-linecap:round;stroke-linejoin:round\"><path d=\"M31 2H10a8 8 0 0 0-8 8v21M207 2h21a8 8 0 0 1 8 8v21m0 176v21a8 8 0 0 1-8 8h-21m-176 0H10a8 8 0 0 1-8-8v-21\"/></svg>';try{this.$overlay.firstElementChild.animate({transform:[\"scale(.98)\",\n\"scale(1.01)\"]},{duration:400,iterations:Infinity,direction:\"alternate\",easing:\"ease-in-out\"})}catch(m){}c.insertBefore(this.$overlay,this.$video.nextSibling)}b.highlightCodeOutline&&(this.$overlay.insertAdjacentHTML(\"beforeend\",'<svg class=\"code-outline-highlight\" preserveAspectRatio=\"none\" style=\"display:none;width:100%;height:100%;fill:none;stroke:#e9b213;stroke-width:5;stroke-dasharray:25;stroke-linecap:round;stroke-linejoin:round\"><polygon/></svg>'),this.$codeOutlineHighlight=this.$overlay.lastElementChild)}this._scanRegion=\nthis._calculateScanRegion(a);requestAnimationFrame(()=>{let m=window.getComputedStyle(a);\"none\"===m.display&&(a.style.setProperty(\"display\",\"block\",\"important\"),h=!0);\"visible\"!==m.visibility&&(a.style.setProperty(\"visibility\",\"visible\",\"important\"),h=!0);h&&(console.warn(\"QrScanner has overwritten the video hiding style to avoid Safari stopping the playback.\"),a.style.opacity=\"0\",a.style.width=\"0\",a.style.height=\"0\",this.$overlay&&this.$overlay.parentElement&&this.$overlay.parentElement.removeChild(this.$overlay),\ndelete this.$overlay,delete this.$codeOutlineHighlight);this.$overlay&&this._updateOverlay()});a.addEventListener(\"play\",this._onPlay);a.addEventListener(\"loadedmetadata\",this._onLoadedMetaData);document.addEventListener(\"visibilitychange\",this._onVisibilityChange);window.addEventListener(\"resize\",this._updateOverlay);this._qrEnginePromise=e.createQrEngine()}static set WORKER_PATH(a){console.warn(\"Setting QrScanner.WORKER_PATH is not required and not supported anymore. Have a look at the README for new setup instructions.\")}static async hasCamera(){try{return!!(await e.listCameras(!1)).length}catch(a){return!1}}static async listCameras(a=\n!1){if(!navigator.mediaDevices)return[];let b=async()=>(await navigator.mediaDevices.enumerateDevices()).filter(d=>\"videoinput\"===d.kind),c;try{a&&(await b()).every(d=>!d.label)&&(c=await navigator.mediaDevices.getUserMedia({audio:!1,video:!0}))}catch(d){}try{return(await b()).map((d,f)=>({id:d.deviceId,label:d.label||(0===f?\"Default Camera\":`Camera ${f+1}`)}))}finally{c&&(console.warn(\"Call listCameras after successfully starting a QR scanner to avoid creating a temporary video stream\"),e._stopVideoStream(c))}}async hasFlash(){let a;\ntry{if(this.$video.srcObject){if(!(this.$video.srcObject instanceof MediaStream))return!1;a=this.$video.srcObject}else a=(await this._getCameraStream()).stream;return\"torch\"in a.getVideoTracks()[0].getSettings()}catch(b){return!1}finally{a&&a!==this.$video.srcObject&&(console.warn(\"Call hasFlash after successfully starting the scanner to avoid creating a temporary video stream\"),e._stopVideoStream(a))}}isFlashOn(){return this._flashOn}async toggleFlash(){this._flashOn?await this.turnFlashOff():await this.turnFlashOn()}async turnFlashOn(){if(!this._flashOn&&\n!this._destroyed&&(this._flashOn=!0,this._active&&!this._paused))try{if(!await this.hasFlash())throw\"No flash available\";await this.$video.srcObject.getVideoTracks()[0].applyConstraints({advanced:[{torch:!0}]})}catch(a){throw this._flashOn=!1,a;}}async turnFlashOff(){this._flashOn&&(this._flashOn=!1,await this._restartVideoStream())}destroy(){this.$video.removeEventListener(\"loadedmetadata\",this._onLoadedMetaData);this.$video.removeEventListener(\"play\",this._onPlay);document.removeEventListener(\"visibilitychange\",\nthis._onVisibilityChange);window.removeEventListener(\"resize\",this._updateOverlay);this._destroyed=!0;this._flashOn=!1;this.stop();e._postWorkerMessage(this._qrEnginePromise,\"close\")}async start(){if(this._destroyed)throw Error(\"The QR scanner can not be started as it had been destroyed.\");if(!this._active||this._paused)if(\"https:\"!==window.location.protocol&&console.warn(\"The camera stream is only accessible if the page is transferred via https.\"),this._active=!0,!document.hidden)if(this._paused=\n!1,this.$video.srcObject)await this.$video.play();else try{let {stream:a,facingMode:b}=await this._getCameraStream();!this._active||this._paused?e._stopVideoStream(a):(this._setVideoMirror(b),this.$video.srcObject=a,await this.$video.play(),this._flashOn&&(this._flashOn=!1,this.turnFlashOn().catch(()=>{})))}catch(a){if(!this._paused)throw this._active=!1,a;}}stop(){this.pause();this._active=!1}async pause(a=!1){this._paused=!0;if(!this._active)return!0;this.$video.pause();this.$overlay&&(this.$overlay.style.display=\n\"none\");let b=()=>{this.$video.srcObject instanceof MediaStream&&(e._stopVideoStream(this.$video.srcObject),this.$video.srcObject=null)};if(a)return b(),!0;await new Promise(c=>setTimeout(c,300));if(!this._paused)return!1;b();return!0}async setCamera(a){a!==this._preferredCamera&&(this._preferredCamera=a,await this._restartVideoStream())}static async scanImage(a,b,c,d,f=!1,h=!1){let m,n=!1;b&&(\"scanRegion\"in b||\"qrEngine\"in b||\"canvas\"in b||\"disallowCanvasResizing\"in b||\"alsoTryWithoutScanRegion\"in\nb||\"returnDetailedScanResult\"in b)?(m=b.scanRegion,c=b.qrEngine,d=b.canvas,f=b.disallowCanvasResizing||!1,h=b.alsoTryWithoutScanRegion||!1,n=!0):b||c||d||f||h?console.warn(\"You're using a deprecated api for scanImage which will be removed in the future.\"):console.warn(\"Note that the return type of scanImage will change in the future. To already switch to the new api today, you can pass returnDetailedScanResult: true.\");b=!!c;try{let p,k;[c,p]=await Promise.all([c||e.createQrEngine(),e._loadImage(a)]);\n[d,k]=e._drawToCanvas(p,m,d,f);let q;if(c instanceof Worker){let g=c;b||e._postWorkerMessageSync(g,\"inversionMode\",\"both\");q=await new Promise((l,v)=>{let w,u,r,y=-1;u=t=>{t.data.id===y&&(g.removeEventListener(\"message\",u),g.removeEventListener(\"error\",r),clearTimeout(w),null!==t.data.data?l({data:t.data.data,cornerPoints:e._convertPoints(t.data.cornerPoints,m)}):v(e.NO_QR_CODE_FOUND))};r=t=>{g.removeEventListener(\"message\",u);g.removeEventListener(\"error\",r);clearTimeout(w);v(\"Scanner error: \"+(t?\nt.message||t:\"Unknown Error\"))};g.addEventListener(\"message\",u);g.addEventListener(\"error\",r);w=setTimeout(()=>r(\"timeout\"),1E4);let x=k.getImageData(0,0,d.width,d.height);y=e._postWorkerMessageSync(g,\"decode\",x,[x.data.buffer])})}else q=await Promise.race([new Promise((g,l)=>window.setTimeout(()=>l(\"Scanner error: timeout\"),1E4)),(async()=>{try{var [g]=await c.detect(d);if(!g)throw e.NO_QR_CODE_FOUND;return{data:g.rawValue,cornerPoints:e._convertPoints(g.cornerPoints,m)}}catch(l){g=l.message||l;\nif(/not implemented|service unavailable/.test(g))return e._disableBarcodeDetector=!0,e.scanImage(a,{scanRegion:m,canvas:d,disallowCanvasResizing:f,alsoTryWithoutScanRegion:h});throw`Scanner error: ${g}`;}})()]);return n?q:q.data}catch(p){if(!m||!h)throw p;let k=await e.scanImage(a,{qrEngine:c,canvas:d,disallowCanvasResizing:f});return n?k:k.data}finally{b||e._postWorkerMessage(c,\"close\")}}setGrayscaleWeights(a,b,c,d=!0){e._postWorkerMessage(this._qrEnginePromise,\"grayscaleWeights\",{red:a,green:b,\nblue:c,useIntegerApproximation:d})}setInversionMode(a){e._postWorkerMessage(this._qrEnginePromise,\"inversionMode\",a)}static async createQrEngine(a){a&&console.warn(\"Specifying a worker path is not required and not supported anymore.\");a=()=>__webpack_require__.e(/*! import() */ \"node_modules_qr-scanner_qr-scanner-worker_min_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./qr-scanner-worker.min.js */ \"./node_modules/qr-scanner/qr-scanner-worker.min.js\")).then(c=>c.createWorker());if(!(!e._disableBarcodeDetector&&\"BarcodeDetector\"in window&&BarcodeDetector.getSupportedFormats&&(await BarcodeDetector.getSupportedFormats()).includes(\"qr_code\")))return a();let b=navigator.userAgentData;\nreturn b&&b.brands.some(({brand:c})=>/Chromium/i.test(c))&&/mac ?OS/i.test(b.platform)&&await b.getHighEntropyValues([\"architecture\",\"platformVersion\"]).then(({architecture:c,platformVersion:d})=>/arm/i.test(c||\"arm\")&&13<=parseInt(d||\"13\")).catch(()=>!0)?a():new BarcodeDetector({formats:[\"qr_code\"]})}_onPlay(){this._scanRegion=this._calculateScanRegion(this.$video);this._updateOverlay();this.$overlay&&(this.$overlay.style.display=\"\");this._scanFrame()}_onLoadedMetaData(){this._scanRegion=this._calculateScanRegion(this.$video);\nthis._updateOverlay()}_onVisibilityChange(){document.hidden?this.pause():this._active&&this.start()}_calculateScanRegion(a){let b=Math.round(2/3*Math.min(a.videoWidth,a.videoHeight));return{x:Math.round((a.videoWidth-b)/2),y:Math.round((a.videoHeight-b)/2),width:b,height:b,downScaledWidth:this._legacyCanvasSize,downScaledHeight:this._legacyCanvasSize}}_updateOverlay(){requestAnimationFrame(()=>{if(this.$overlay){var a=this.$video,b=a.videoWidth,c=a.videoHeight,d=a.offsetWidth,f=a.offsetHeight,h=a.offsetLeft,\nm=a.offsetTop,n=window.getComputedStyle(a),p=n.objectFit,k=b/c,q=d/f;switch(p){case \"none\":var g=b;var l=c;break;case \"fill\":g=d;l=f;break;default:(\"cover\"===p?k>q:k<q)?(l=f,g=l*k):(g=d,l=g/k),\"scale-down\"===p&&(g=Math.min(g,b),l=Math.min(l,c))}var [v,w]=n.objectPosition.split(\" \").map((r,y)=>{const x=parseFloat(r);return r.endsWith(\"%\")?(y?f-l:d-g)*x/100:x});n=this._scanRegion.width||b;q=this._scanRegion.height||c;p=this._scanRegion.x||0;var u=this._scanRegion.y||0;k=this.$overlay.style;k.width=\n`${n/b*g}px`;k.height=`${q/c*l}px`;k.top=`${m+w+u/c*l}px`;c=/scaleX\\(-1\\)/.test(a.style.transform);k.left=`${h+(c?d-v-g:v)+(c?b-p-n:p)/b*g}px`;k.transform=a.style.transform}})}static _convertPoints(a,b){if(!b)return a;let c=b.x||0,d=b.y||0,f=b.width&&b.downScaledWidth?b.width/b.downScaledWidth:1;b=b.height&&b.downScaledHeight?b.height/b.downScaledHeight:1;for(let h of a)h.x=h.x*f+c,h.y=h.y*b+d;return a}_scanFrame(){!this._active||this.$video.paused||this.$video.ended||(\"requestVideoFrameCallback\"in\nthis.$video?this.$video.requestVideoFrameCallback.bind(this.$video):requestAnimationFrame)(async()=>{if(!(1>=this.$video.readyState)){var a=Date.now()-this._lastScanTimestamp,b=1E3/this._maxScansPerSecond;a<b&&await new Promise(d=>setTimeout(d,b-a));this._lastScanTimestamp=Date.now();try{var c=await e.scanImage(this.$video,{scanRegion:this._scanRegion,qrEngine:this._qrEnginePromise,canvas:this.$canvas})}catch(d){if(!this._active)return;this._onDecodeError(d)}!e._disableBarcodeDetector||await this._qrEnginePromise instanceof\nWorker||(this._qrEnginePromise=e.createQrEngine());c?(this._onDecode?this._onDecode(c):this._legacyOnDecode&&this._legacyOnDecode(c.data),this.$codeOutlineHighlight&&(clearTimeout(this._codeOutlineHighlightRemovalTimeout),this._codeOutlineHighlightRemovalTimeout=void 0,this.$codeOutlineHighlight.setAttribute(\"viewBox\",`${this._scanRegion.x||0} `+`${this._scanRegion.y||0} `+`${this._scanRegion.width||this.$video.videoWidth} `+`${this._scanRegion.height||this.$video.videoHeight}`),this.$codeOutlineHighlight.firstElementChild.setAttribute(\"points\",\nc.cornerPoints.map(({x:d,y:f})=>`${d},${f}`).join(\" \")),this.$codeOutlineHighlight.style.display=\"\")):this.$codeOutlineHighlight&&!this._codeOutlineHighlightRemovalTimeout&&(this._codeOutlineHighlightRemovalTimeout=setTimeout(()=>this.$codeOutlineHighlight.style.display=\"none\",100))}this._scanFrame()})}_onDecodeError(a){a!==e.NO_QR_CODE_FOUND&&console.log(a)}async _getCameraStream(){if(!navigator.mediaDevices)throw\"Camera not found.\";let a=/^(environment|user)$/.test(this._preferredCamera)?\"facingMode\":\n\"deviceId\",b=[{width:{min:1024}},{width:{min:768}},{}],c=b.map(d=>Object.assign({},d,{[a]:{exact:this._preferredCamera}}));for(let d of[...c,...b])try{let f=await navigator.mediaDevices.getUserMedia({video:d,audio:!1}),h=this._getFacingMode(f)||(d.facingMode?this._preferredCamera:\"environment\"===this._preferredCamera?\"user\":\"environment\");return{stream:f,facingMode:h}}catch(f){}throw\"Camera not found.\";}async _restartVideoStream(){let a=this._paused;await this.pause(!0)&&!a&&this._active&&await this.start()}static _stopVideoStream(a){for(let b of a.getTracks())b.stop(),\na.removeTrack(b)}_setVideoMirror(a){this.$video.style.transform=\"scaleX(\"+(\"user\"===a?-1:1)+\")\"}_getFacingMode(a){return(a=a.getVideoTracks()[0])?/rear|back|environment/i.test(a.label)?\"environment\":/front|user|face/i.test(a.label)?\"user\":null:null}static _drawToCanvas(a,b,c,d=!1){c=c||document.createElement(\"canvas\");let f=b&&b.x?b.x:0,h=b&&b.y?b.y:0,m=b&&b.width?b.width:a.videoWidth||a.width,n=b&&b.height?b.height:a.videoHeight||a.height;d||(d=b&&b.downScaledWidth?b.downScaledWidth:m,b=b&&b.downScaledHeight?\nb.downScaledHeight:n,c.width!==d&&(c.width=d),c.height!==b&&(c.height=b));b=c.getContext(\"2d\",{alpha:!1});b.imageSmoothingEnabled=!1;b.drawImage(a,f,h,m,n,0,0,c.width,c.height);return[c,b]}static async _loadImage(a){if(a instanceof Image)return await e._awaitImageLoad(a),a;if(a instanceof HTMLVideoElement||a instanceof HTMLCanvasElement||a instanceof SVGImageElement||\"OffscreenCanvas\"in window&&a instanceof OffscreenCanvas||\"ImageBitmap\"in window&&a instanceof ImageBitmap)return a;if(a instanceof\nFile||a instanceof Blob||a instanceof URL||\"string\"===typeof a){let b=new Image;b.src=a instanceof File||a instanceof Blob?URL.createObjectURL(a):a.toString();try{return await e._awaitImageLoad(b),b}finally{(a instanceof File||a instanceof Blob)&&URL.revokeObjectURL(b.src)}}else throw\"Unsupported image type.\";}static async _awaitImageLoad(a){a.complete&&0!==a.naturalWidth||await new Promise((b,c)=>{let d=f=>{a.removeEventListener(\"load\",d);a.removeEventListener(\"error\",d);f instanceof ErrorEvent?\nc(\"Image load error\"):b()};a.addEventListener(\"load\",d);a.addEventListener(\"error\",d)})}static async _postWorkerMessage(a,b,c,d){return e._postWorkerMessageSync(await a,b,c,d)}static _postWorkerMessageSync(a,b,c,d){if(!(a instanceof Worker))return-1;let f=e._workerMessageId++;a.postMessage({id:f,type:b,data:c},d);return f}}e.DEFAULT_CANVAS_SIZE=400;e.NO_QR_CODE_FOUND=\"No QR code found\";e._disableBarcodeDetector=!1;e._workerMessageId=0;/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (e);\n//# sourceMappingURL=qr-scanner.min.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcXItc2Nhbm5lci9xci1zY2FubmVyLm1pbi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsUUFBUSx1QkFBdUIsNkNBQTZDLG9DQUFvQywyQkFBMkIsMkJBQTJCLDJEQUEyRCxjQUFjLDhDQUE4QztBQUM3Uix3QkFBd0IsMkJBQTJCLG1GQUFtRixxR0FBcUcsa0VBQWtFLDBGQUEwRixxRUFBcUUscUNBQXFDO0FBQ2pmLGtDQUFrQyw2REFBNkQsbURBQW1ELDZCQUE2QixpQkFBaUIsV0FBVyxTQUFTLDZCQUE2QiwrREFBK0Qsa0JBQWtCLGtEQUFrRCxjQUFjLHVEQUF1RCxzQkFBc0Isc0JBQXNCO0FBQ3JlLHVCQUF1QixxREFBcUQsOEJBQThCLDBJQUEwSSxXQUFXLFlBQVksT0FBTyxNQUFNLFVBQVUsZUFBZSxlQUFlLHFCQUFxQixxSkFBcUosSUFBSSx5Q0FBeUM7QUFDdmhCLGVBQWUsRUFBRSw0RUFBNEUsRUFBRSxVQUFVLHNEQUFzRCwwSkFBMEosV0FBVyxZQUFZLFVBQVUsZUFBZSxlQUFlLG9CQUFvQixxQkFBcUIscUdBQXFHO0FBQ3RnQiw2QkFBNkIsMkJBQTJCLGlDQUFpQyw4RUFBOEUseUZBQXlGO0FBQ2hRLHdEQUF3RCxxQ0FBcUMsRUFBRSx3Q0FBd0MsNERBQTRELHVFQUF1RSxzREFBc0QseUNBQXlDLDBCQUEwQiwrSUFBK0kseUJBQXlCLElBQUkseUNBQXlDLFNBQVMsVUFBVTtBQUMzbUIsSUFBSSxvQ0FBb0Msb0dBQW9HLElBQUksaUZBQWlGLGtCQUFrQixHQUFHLFVBQVUsSUFBSSwrQkFBK0IsK0RBQStELElBQUksR0FBRyxHQUFHLFFBQVEsaUpBQWlKLGlCQUFpQjtBQUN0aEIsSUFBSSwwQkFBMEIsNERBQTRELHdCQUF3Qiw4Q0FBOEMsb0RBQW9ELFNBQVMsU0FBUyxRQUFRLHdLQUF3SyxZQUFZLHFCQUFxQixvQkFBb0IsaUVBQWlFLG9CQUFvQjtBQUNoaUIscUVBQXFFLG9EQUFvRCxrRUFBa0UsV0FBVyxTQUFTLEVB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ZUFBZSxtQkFBbUIsSUFBSSxVQUFVLDBCQUEwQixzQ0FBc0MsNkJBQTZCLHFCQUFxQixpRUFBZSxDQUFDO0FBQ3ZjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3FyLXNjYW5uZXIvcXItc2Nhbm5lci5taW4uanM/YWEzYyJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBle2NvbnN0cnVjdG9yKGEsYixjLGQsZil7dGhpcy5fbGVnYWN5Q2FudmFzU2l6ZT1lLkRFRkFVTFRfQ0FOVkFTX1NJWkU7dGhpcy5fcHJlZmVycmVkQ2FtZXJhPVwiZW52aXJvbm1lbnRcIjt0aGlzLl9tYXhTY2Fuc1BlclNlY29uZD0yNTt0aGlzLl9sYXN0U2NhblRpbWVzdGFtcD0tMTt0aGlzLl9kZXN0cm95ZWQ9dGhpcy5fZmxhc2hPbj10aGlzLl9wYXVzZWQ9dGhpcy5fYWN0aXZlPSExO3RoaXMuJHZpZGVvPWE7dGhpcy4kY2FudmFzPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7YyYmXCJvYmplY3RcIj09PXR5cGVvZiBjP3RoaXMuX29uRGVjb2RlPWI6KGN8fGR8fGY/Y29uc29sZS53YXJuKFwiWW91J3JlIHVzaW5nIGEgZGVwcmVjYXRlZCB2ZXJzaW9uIG9mIHRoZSBRclNjYW5uZXIgY29uc3RydWN0b3Igd2hpY2ggd2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmVcIik6Y29uc29sZS53YXJuKFwiTm90ZSB0aGF0IHRoZSB0eXBlIG9mIHRoZSBzY2FuIHJlc3VsdCBwYXNzZWQgdG8gb25EZWNvZGUgd2lsbCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS4gVG8gYWxyZWFkeSBzd2l0Y2ggdG8gdGhlIG5ldyBhcGkgdG9kYXksIHlvdSBjYW4gcGFzcyByZXR1cm5EZXRhaWxlZFNjYW5SZXN1bHQ6IHRydWUuXCIpLFxudGhpcy5fbGVnYWN5T25EZWNvZGU9Yik7Yj1cIm9iamVjdFwiPT09dHlwZW9mIGM/Yzp7fTt0aGlzLl9vbkRlY29kZUVycm9yPWIub25EZWNvZGVFcnJvcnx8KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBjP2M6dGhpcy5fb25EZWNvZGVFcnJvcik7dGhpcy5fY2FsY3VsYXRlU2NhblJlZ2lvbj1iLmNhbGN1bGF0ZVNjYW5SZWdpb258fChcImZ1bmN0aW9uXCI9PT10eXBlb2YgZD9kOnRoaXMuX2NhbGN1bGF0ZVNjYW5SZWdpb24pO3RoaXMuX3ByZWZlcnJlZENhbWVyYT1iLnByZWZlcnJlZENhbWVyYXx8Znx8dGhpcy5fcHJlZmVycmVkQ2FtZXJhO3RoaXMuX2xlZ2FjeUNhbnZhc1NpemU9XCJudW1iZXJcIj09PXR5cGVvZiBjP2M6XCJudW1iZXJcIj09PXR5cGVvZiBkP2Q6dGhpcy5fbGVnYWN5Q2FudmFzU2l6ZTt0aGlzLl9tYXhTY2Fuc1BlclNlY29uZD1iLm1heFNjYW5zUGVyU2Vjb25kfHx0aGlzLl9tYXhTY2Fuc1BlclNlY29uZDt0aGlzLl9vblBsYXk9dGhpcy5fb25QbGF5LmJpbmQodGhpcyk7dGhpcy5fb25Mb2FkZWRNZXRhRGF0YT1cbnRoaXMuX29uTG9hZGVkTWV0YURhdGEuYmluZCh0aGlzKTt0aGlzLl9vblZpc2liaWxpdHlDaGFuZ2U9dGhpcy5fb25WaXNpYmlsaXR5Q2hhbmdlLmJpbmQodGhpcyk7dGhpcy5fdXBkYXRlT3ZlcmxheT10aGlzLl91cGRhdGVPdmVybGF5LmJpbmQodGhpcyk7YS5kaXNhYmxlUGljdHVyZUluUGljdHVyZT0hMDthLnBsYXlzSW5saW5lPSEwO2EubXV0ZWQ9ITA7bGV0IGg9ITE7YS5oaWRkZW4mJihhLmhpZGRlbj0hMSxoPSEwKTtkb2N1bWVudC5ib2R5LmNvbnRhaW5zKGEpfHwoZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhKSxoPSEwKTtjPWEucGFyZW50RWxlbWVudDtpZihiLmhpZ2hsaWdodFNjYW5SZWdpb258fGIuaGlnaGxpZ2h0Q29kZU91dGxpbmUpe2Q9ISFiLm92ZXJsYXk7dGhpcy4kb3ZlcmxheT1iLm92ZXJsYXl8fGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7Zj10aGlzLiRvdmVybGF5LnN0eWxlO2YucG9zaXRpb249XCJhYnNvbHV0ZVwiO2YuZGlzcGxheT1cIm5vbmVcIjtcbmYucG9pbnRlckV2ZW50cz1cIm5vbmVcIjt0aGlzLiRvdmVybGF5LmNsYXNzTGlzdC5hZGQoXCJzY2FuLXJlZ2lvbi1oaWdobGlnaHRcIik7aWYoIWQmJmIuaGlnaGxpZ2h0U2NhblJlZ2lvbil7dGhpcy4kb3ZlcmxheS5pbm5lckhUTUw9JzxzdmcgY2xhc3M9XCJzY2FuLXJlZ2lvbi1oaWdobGlnaHQtc3ZnXCIgdmlld0JveD1cIjAgMCAyMzggMjM4XCIgcHJlc2VydmVBc3BlY3RSYXRpbz1cIm5vbmVcIiBzdHlsZT1cInBvc2l0aW9uOmFic29sdXRlO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7bGVmdDowO3RvcDowO2ZpbGw6bm9uZTtzdHJva2U6I2U5YjIxMztzdHJva2Utd2lkdGg6NDtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmRcIj48cGF0aCBkPVwiTTMxIDJIMTBhOCA4IDAgMCAwLTggOHYyMU0yMDcgMmgyMWE4IDggMCAwIDEgOCA4djIxbTAgMTc2djIxYTggOCAwIDAgMS04IDhoLTIxbS0xNzYgMEgxMGE4IDggMCAwIDEtOC04di0yMVwiLz48L3N2Zz4nO3RyeXt0aGlzLiRvdmVybGF5LmZpcnN0RWxlbWVudENoaWxkLmFuaW1hdGUoe3RyYW5zZm9ybTpbXCJzY2FsZSguOTgpXCIsXG5cInNjYWxlKDEuMDEpXCJdfSx7ZHVyYXRpb246NDAwLGl0ZXJhdGlvbnM6SW5maW5pdHksZGlyZWN0aW9uOlwiYWx0ZXJuYXRlXCIsZWFzaW5nOlwiZWFzZS1pbi1vdXRcIn0pfWNhdGNoKG0pe31jLmluc2VydEJlZm9yZSh0aGlzLiRvdmVybGF5LHRoaXMuJHZpZGVvLm5leHRTaWJsaW5nKX1iLmhpZ2hsaWdodENvZGVPdXRsaW5lJiYodGhpcy4kb3ZlcmxheS5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIiwnPHN2ZyBjbGFzcz1cImNvZGUtb3V0bGluZS1oaWdobGlnaHRcIiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVwibm9uZVwiIHN0eWxlPVwiZGlzcGxheTpub25lO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7ZmlsbDpub25lO3N0cm9rZTojZTliMjEzO3N0cm9rZS13aWR0aDo1O3N0cm9rZS1kYXNoYXJyYXk6MjU7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kXCI+PHBvbHlnb24vPjwvc3ZnPicpLHRoaXMuJGNvZGVPdXRsaW5lSGlnaGxpZ2h0PXRoaXMuJG92ZXJsYXkubGFzdEVsZW1lbnRDaGlsZCl9dGhpcy5fc2NhblJlZ2lvbj1cbnRoaXMuX2NhbGN1bGF0ZVNjYW5SZWdpb24oYSk7cmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpPT57bGV0IG09d2luZG93LmdldENvbXB1dGVkU3R5bGUoYSk7XCJub25lXCI9PT1tLmRpc3BsYXkmJihhLnN0eWxlLnNldFByb3BlcnR5KFwiZGlzcGxheVwiLFwiYmxvY2tcIixcImltcG9ydGFudFwiKSxoPSEwKTtcInZpc2libGVcIiE9PW0udmlzaWJpbGl0eSYmKGEuc3R5bGUuc2V0UHJvcGVydHkoXCJ2aXNpYmlsaXR5XCIsXCJ2aXNpYmxlXCIsXCJpbXBvcnRhbnRcIiksaD0hMCk7aCYmKGNvbnNvbGUud2FybihcIlFyU2Nhbm5lciBoYXMgb3ZlcndyaXR0ZW4gdGhlIHZpZGVvIGhpZGluZyBzdHlsZSB0byBhdm9pZCBTYWZhcmkgc3RvcHBpbmcgdGhlIHBsYXliYWNrLlwiKSxhLnN0eWxlLm9wYWNpdHk9XCIwXCIsYS5zdHlsZS53aWR0aD1cIjBcIixhLnN0eWxlLmhlaWdodD1cIjBcIix0aGlzLiRvdmVybGF5JiZ0aGlzLiRvdmVybGF5LnBhcmVudEVsZW1lbnQmJnRoaXMuJG92ZXJsYXkucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLiRvdmVybGF5KSxcbmRlbGV0ZSB0aGlzLiRvdmVybGF5LGRlbGV0ZSB0aGlzLiRjb2RlT3V0bGluZUhpZ2hsaWdodCk7dGhpcy4kb3ZlcmxheSYmdGhpcy5fdXBkYXRlT3ZlcmxheSgpfSk7YS5hZGRFdmVudExpc3RlbmVyKFwicGxheVwiLHRoaXMuX29uUGxheSk7YS5hZGRFdmVudExpc3RlbmVyKFwibG9hZGVkbWV0YWRhdGFcIix0aGlzLl9vbkxvYWRlZE1ldGFEYXRhKTtkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLHRoaXMuX29uVmlzaWJpbGl0eUNoYW5nZSk7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIix0aGlzLl91cGRhdGVPdmVybGF5KTt0aGlzLl9xckVuZ2luZVByb21pc2U9ZS5jcmVhdGVRckVuZ2luZSgpfXN0YXRpYyBzZXQgV09SS0VSX1BBVEgoYSl7Y29uc29sZS53YXJuKFwiU2V0dGluZyBRclNjYW5uZXIuV09SS0VSX1BBVEggaXMgbm90IHJlcXVpcmVkIGFuZCBub3Qgc3VwcG9ydGVkIGFueW1vcmUuIEhhdmUgYSBsb29rIGF0IHRoZSBSRUFETUUgZm9yIG5ldyBzZXR1cCBpbnN0cnVjdGlvbnMuXCIpfXN0YXRpYyBhc3luYyBoYXNDYW1lcmEoKXt0cnl7cmV0dXJuISEoYXdhaXQgZS5saXN0Q2FtZXJhcyghMSkpLmxlbmd0aH1jYXRjaChhKXtyZXR1cm4hMX19c3RhdGljIGFzeW5jIGxpc3RDYW1lcmFzKGE9XG4hMSl7aWYoIW5hdmlnYXRvci5tZWRpYURldmljZXMpcmV0dXJuW107bGV0IGI9YXN5bmMoKT0+KGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpKS5maWx0ZXIoZD0+XCJ2aWRlb2lucHV0XCI9PT1kLmtpbmQpLGM7dHJ5e2EmJihhd2FpdCBiKCkpLmV2ZXJ5KGQ9PiFkLmxhYmVsKSYmKGM9YXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoe2F1ZGlvOiExLHZpZGVvOiEwfSkpfWNhdGNoKGQpe310cnl7cmV0dXJuKGF3YWl0IGIoKSkubWFwKChkLGYpPT4oe2lkOmQuZGV2aWNlSWQsbGFiZWw6ZC5sYWJlbHx8KDA9PT1mP1wiRGVmYXVsdCBDYW1lcmFcIjpgQ2FtZXJhICR7ZisxfWApfSkpfWZpbmFsbHl7YyYmKGNvbnNvbGUud2FybihcIkNhbGwgbGlzdENhbWVyYXMgYWZ0ZXIgc3VjY2Vzc2Z1bGx5IHN0YXJ0aW5nIGEgUVIgc2Nhbm5lciB0byBhdm9pZCBjcmVhdGluZyBhIHRlbXBvcmFyeSB2aWRlbyBzdHJlYW1cIiksZS5fc3RvcFZpZGVvU3RyZWFtKGMpKX19YXN5bmMgaGFzRmxhc2goKXtsZXQgYTtcbnRyeXtpZih0aGlzLiR2aWRlby5zcmNPYmplY3Qpe2lmKCEodGhpcy4kdmlkZW8uc3JjT2JqZWN0IGluc3RhbmNlb2YgTWVkaWFTdHJlYW0pKXJldHVybiExO2E9dGhpcy4kdmlkZW8uc3JjT2JqZWN0fWVsc2UgYT0oYXdhaXQgdGhpcy5fZ2V0Q2FtZXJhU3RyZWFtKCkpLnN0cmVhbTtyZXR1cm5cInRvcmNoXCJpbiBhLmdldFZpZGVvVHJhY2tzKClbMF0uZ2V0U2V0dGluZ3MoKX1jYXRjaChiKXtyZXR1cm4hMX1maW5hbGx5e2EmJmEhPT10aGlzLiR2aWRlby5zcmNPYmplY3QmJihjb25zb2xlLndhcm4oXCJDYWxsIGhhc0ZsYXNoIGFmdGVyIHN1Y2Nlc3NmdWxseSBzdGFydGluZyB0aGUgc2Nhbm5lciB0byBhdm9pZCBjcmVhdGluZyBhIHRlbXBvcmFyeSB2aWRlbyBzdHJlYW1cIiksZS5fc3RvcFZpZGVvU3RyZWFtKGEpKX19aXNGbGFzaE9uKCl7cmV0dXJuIHRoaXMuX2ZsYXNoT259YXN5bmMgdG9nZ2xlRmxhc2goKXt0aGlzLl9mbGFzaE9uP2F3YWl0IHRoaXMudHVybkZsYXNoT2ZmKCk6YXdhaXQgdGhpcy50dXJuRmxhc2hPbigpfWFzeW5jIHR1cm5GbGFzaE9uKCl7aWYoIXRoaXMuX2ZsYXNoT24mJlxuIXRoaXMuX2Rlc3Ryb3llZCYmKHRoaXMuX2ZsYXNoT249ITAsdGhpcy5fYWN0aXZlJiYhdGhpcy5fcGF1c2VkKSl0cnl7aWYoIWF3YWl0IHRoaXMuaGFzRmxhc2goKSl0aHJvd1wiTm8gZmxhc2ggYXZhaWxhYmxlXCI7YXdhaXQgdGhpcy4kdmlkZW8uc3JjT2JqZWN0LmdldFZpZGVvVHJhY2tzKClbMF0uYXBwbHlDb25zdHJhaW50cyh7YWR2YW5jZWQ6W3t0b3JjaDohMH1dfSl9Y2F0Y2goYSl7dGhyb3cgdGhpcy5fZmxhc2hPbj0hMSxhO319YXN5bmMgdHVybkZsYXNoT2ZmKCl7dGhpcy5fZmxhc2hPbiYmKHRoaXMuX2ZsYXNoT249ITEsYXdhaXQgdGhpcy5fcmVzdGFydFZpZGVvU3RyZWFtKCkpfWRlc3Ryb3koKXt0aGlzLiR2aWRlby5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZGVkbWV0YWRhdGFcIix0aGlzLl9vbkxvYWRlZE1ldGFEYXRhKTt0aGlzLiR2aWRlby5yZW1vdmVFdmVudExpc3RlbmVyKFwicGxheVwiLHRoaXMuX29uUGxheSk7ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIixcbnRoaXMuX29uVmlzaWJpbGl0eUNoYW5nZSk7d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIix0aGlzLl91cGRhdGVPdmVybGF5KTt0aGlzLl9kZXN0cm95ZWQ9ITA7dGhpcy5fZmxhc2hPbj0hMTt0aGlzLnN0b3AoKTtlLl9wb3N0V29ya2VyTWVzc2FnZSh0aGlzLl9xckVuZ2luZVByb21pc2UsXCJjbG9zZVwiKX1hc3luYyBzdGFydCgpe2lmKHRoaXMuX2Rlc3Ryb3llZCl0aHJvdyBFcnJvcihcIlRoZSBRUiBzY2FubmVyIGNhbiBub3QgYmUgc3RhcnRlZCBhcyBpdCBoYWQgYmVlbiBkZXN0cm95ZWQuXCIpO2lmKCF0aGlzLl9hY3RpdmV8fHRoaXMuX3BhdXNlZClpZihcImh0dHBzOlwiIT09d2luZG93LmxvY2F0aW9uLnByb3RvY29sJiZjb25zb2xlLndhcm4oXCJUaGUgY2FtZXJhIHN0cmVhbSBpcyBvbmx5IGFjY2Vzc2libGUgaWYgdGhlIHBhZ2UgaXMgdHJhbnNmZXJyZWQgdmlhIGh0dHBzLlwiKSx0aGlzLl9hY3RpdmU9ITAsIWRvY3VtZW50LmhpZGRlbilpZih0aGlzLl9wYXVzZWQ9XG4hMSx0aGlzLiR2aWRlby5zcmNPYmplY3QpYXdhaXQgdGhpcy4kdmlkZW8ucGxheSgpO2Vsc2UgdHJ5e2xldCB7c3RyZWFtOmEsZmFjaW5nTW9kZTpifT1hd2FpdCB0aGlzLl9nZXRDYW1lcmFTdHJlYW0oKTshdGhpcy5fYWN0aXZlfHx0aGlzLl9wYXVzZWQ/ZS5fc3RvcFZpZGVvU3RyZWFtKGEpOih0aGlzLl9zZXRWaWRlb01pcnJvcihiKSx0aGlzLiR2aWRlby5zcmNPYmplY3Q9YSxhd2FpdCB0aGlzLiR2aWRlby5wbGF5KCksdGhpcy5fZmxhc2hPbiYmKHRoaXMuX2ZsYXNoT249ITEsdGhpcy50dXJuRmxhc2hPbigpLmNhdGNoKCgpPT57fSkpKX1jYXRjaChhKXtpZighdGhpcy5fcGF1c2VkKXRocm93IHRoaXMuX2FjdGl2ZT0hMSxhO319c3RvcCgpe3RoaXMucGF1c2UoKTt0aGlzLl9hY3RpdmU9ITF9YXN5bmMgcGF1c2UoYT0hMSl7dGhpcy5fcGF1c2VkPSEwO2lmKCF0aGlzLl9hY3RpdmUpcmV0dXJuITA7dGhpcy4kdmlkZW8ucGF1c2UoKTt0aGlzLiRvdmVybGF5JiYodGhpcy4kb3ZlcmxheS5zdHlsZS5kaXNwbGF5PVxuXCJub25lXCIpO2xldCBiPSgpPT57dGhpcy4kdmlkZW8uc3JjT2JqZWN0IGluc3RhbmNlb2YgTWVkaWFTdHJlYW0mJihlLl9zdG9wVmlkZW9TdHJlYW0odGhpcy4kdmlkZW8uc3JjT2JqZWN0KSx0aGlzLiR2aWRlby5zcmNPYmplY3Q9bnVsbCl9O2lmKGEpcmV0dXJuIGIoKSwhMDthd2FpdCBuZXcgUHJvbWlzZShjPT5zZXRUaW1lb3V0KGMsMzAwKSk7aWYoIXRoaXMuX3BhdXNlZClyZXR1cm4hMTtiKCk7cmV0dXJuITB9YXN5bmMgc2V0Q2FtZXJhKGEpe2EhPT10aGlzLl9wcmVmZXJyZWRDYW1lcmEmJih0aGlzLl9wcmVmZXJyZWRDYW1lcmE9YSxhd2FpdCB0aGlzLl9yZXN0YXJ0VmlkZW9TdHJlYW0oKSl9c3RhdGljIGFzeW5jIHNjYW5JbWFnZShhLGIsYyxkLGY9ITEsaD0hMSl7bGV0IG0sbj0hMTtiJiYoXCJzY2FuUmVnaW9uXCJpbiBifHxcInFyRW5naW5lXCJpbiBifHxcImNhbnZhc1wiaW4gYnx8XCJkaXNhbGxvd0NhbnZhc1Jlc2l6aW5nXCJpbiBifHxcImFsc29UcnlXaXRob3V0U2NhblJlZ2lvblwiaW5cbmJ8fFwicmV0dXJuRGV0YWlsZWRTY2FuUmVzdWx0XCJpbiBiKT8obT1iLnNjYW5SZWdpb24sYz1iLnFyRW5naW5lLGQ9Yi5jYW52YXMsZj1iLmRpc2FsbG93Q2FudmFzUmVzaXppbmd8fCExLGg9Yi5hbHNvVHJ5V2l0aG91dFNjYW5SZWdpb258fCExLG49ITApOmJ8fGN8fGR8fGZ8fGg/Y29uc29sZS53YXJuKFwiWW91J3JlIHVzaW5nIGEgZGVwcmVjYXRlZCBhcGkgZm9yIHNjYW5JbWFnZSB3aGljaCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS5cIik6Y29uc29sZS53YXJuKFwiTm90ZSB0aGF0IHRoZSByZXR1cm4gdHlwZSBvZiBzY2FuSW1hZ2Ugd2lsbCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS4gVG8gYWxyZWFkeSBzd2l0Y2ggdG8gdGhlIG5ldyBhcGkgdG9kYXksIHlvdSBjYW4gcGFzcyByZXR1cm5EZXRhaWxlZFNjYW5SZXN1bHQ6IHRydWUuXCIpO2I9ISFjO3RyeXtsZXQgcCxrO1tjLHBdPWF3YWl0IFByb21pc2UuYWxsKFtjfHxlLmNyZWF0ZVFyRW5naW5lKCksZS5fbG9hZEltYWdlKGEpXSk7XG5bZCxrXT1lLl9kcmF3VG9DYW52YXMocCxtLGQsZik7bGV0IHE7aWYoYyBpbnN0YW5jZW9mIFdvcmtlcil7bGV0IGc9YztifHxlLl9wb3N0V29ya2VyTWVzc2FnZVN5bmMoZyxcImludmVyc2lvbk1vZGVcIixcImJvdGhcIik7cT1hd2FpdCBuZXcgUHJvbWlzZSgobCx2KT0+e2xldCB3LHUscix5PS0xO3U9dD0+e3QuZGF0YS5pZD09PXkmJihnLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsdSksZy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIixyKSxjbGVhclRpbWVvdXQodyksbnVsbCE9PXQuZGF0YS5kYXRhP2woe2RhdGE6dC5kYXRhLmRhdGEsY29ybmVyUG9pbnRzOmUuX2NvbnZlcnRQb2ludHModC5kYXRhLmNvcm5lclBvaW50cyxtKX0pOnYoZS5OT19RUl9DT0RFX0ZPVU5EKSl9O3I9dD0+e2cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIix1KTtnLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLHIpO2NsZWFyVGltZW91dCh3KTt2KFwiU2Nhbm5lciBlcnJvcjogXCIrKHQ/XG50Lm1lc3NhZ2V8fHQ6XCJVbmtub3duIEVycm9yXCIpKX07Zy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLHUpO2cuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIscik7dz1zZXRUaW1lb3V0KCgpPT5yKFwidGltZW91dFwiKSwxRTQpO2xldCB4PWsuZ2V0SW1hZ2VEYXRhKDAsMCxkLndpZHRoLGQuaGVpZ2h0KTt5PWUuX3Bvc3RXb3JrZXJNZXNzYWdlU3luYyhnLFwiZGVjb2RlXCIseCxbeC5kYXRhLmJ1ZmZlcl0pfSl9ZWxzZSBxPWF3YWl0IFByb21pc2UucmFjZShbbmV3IFByb21pc2UoKGcsbCk9PndpbmRvdy5zZXRUaW1lb3V0KCgpPT5sKFwiU2Nhbm5lciBlcnJvcjogdGltZW91dFwiKSwxRTQpKSwoYXN5bmMoKT0+e3RyeXt2YXIgW2ddPWF3YWl0IGMuZGV0ZWN0KGQpO2lmKCFnKXRocm93IGUuTk9fUVJfQ09ERV9GT1VORDtyZXR1cm57ZGF0YTpnLnJhd1ZhbHVlLGNvcm5lclBvaW50czplLl9jb252ZXJ0UG9pbnRzKGcuY29ybmVyUG9pbnRzLG0pfX1jYXRjaChsKXtnPWwubWVzc2FnZXx8bDtcbmlmKC9ub3QgaW1wbGVtZW50ZWR8c2VydmljZSB1bmF2YWlsYWJsZS8udGVzdChnKSlyZXR1cm4gZS5fZGlzYWJsZUJhcmNvZGVEZXRlY3Rvcj0hMCxlLnNjYW5JbWFnZShhLHtzY2FuUmVnaW9uOm0sY2FudmFzOmQsZGlzYWxsb3dDYW52YXNSZXNpemluZzpmLGFsc29UcnlXaXRob3V0U2NhblJlZ2lvbjpofSk7dGhyb3dgU2Nhbm5lciBlcnJvcjogJHtnfWA7fX0pKCldKTtyZXR1cm4gbj9xOnEuZGF0YX1jYXRjaChwKXtpZighbXx8IWgpdGhyb3cgcDtsZXQgaz1hd2FpdCBlLnNjYW5JbWFnZShhLHtxckVuZ2luZTpjLGNhbnZhczpkLGRpc2FsbG93Q2FudmFzUmVzaXppbmc6Zn0pO3JldHVybiBuP2s6ay5kYXRhfWZpbmFsbHl7Ynx8ZS5fcG9zdFdvcmtlck1lc3NhZ2UoYyxcImNsb3NlXCIpfX1zZXRHcmF5c2NhbGVXZWlnaHRzKGEsYixjLGQ9ITApe2UuX3Bvc3RXb3JrZXJNZXNzYWdlKHRoaXMuX3FyRW5naW5lUHJvbWlzZSxcImdyYXlzY2FsZVdlaWdodHNcIix7cmVkOmEsZ3JlZW46YixcbmJsdWU6Yyx1c2VJbnRlZ2VyQXBwcm94aW1hdGlvbjpkfSl9c2V0SW52ZXJzaW9uTW9kZShhKXtlLl9wb3N0V29ya2VyTWVzc2FnZSh0aGlzLl9xckVuZ2luZVByb21pc2UsXCJpbnZlcnNpb25Nb2RlXCIsYSl9c3RhdGljIGFzeW5jIGNyZWF0ZVFyRW5naW5lKGEpe2EmJmNvbnNvbGUud2FybihcIlNwZWNpZnlpbmcgYSB3b3JrZXIgcGF0aCBpcyBub3QgcmVxdWlyZWQgYW5kIG5vdCBzdXBwb3J0ZWQgYW55bW9yZS5cIik7YT0oKT0+aW1wb3J0KFwiLi9xci1zY2FubmVyLXdvcmtlci5taW4uanNcIikudGhlbihjPT5jLmNyZWF0ZVdvcmtlcigpKTtpZighKCFlLl9kaXNhYmxlQmFyY29kZURldGVjdG9yJiZcIkJhcmNvZGVEZXRlY3RvclwiaW4gd2luZG93JiZCYXJjb2RlRGV0ZWN0b3IuZ2V0U3VwcG9ydGVkRm9ybWF0cyYmKGF3YWl0IEJhcmNvZGVEZXRlY3Rvci5nZXRTdXBwb3J0ZWRGb3JtYXRzKCkpLmluY2x1ZGVzKFwicXJfY29kZVwiKSkpcmV0dXJuIGEoKTtsZXQgYj1uYXZpZ2F0b3IudXNlckFnZW50RGF0YTtcbnJldHVybiBiJiZiLmJyYW5kcy5zb21lKCh7YnJhbmQ6Y30pPT4vQ2hyb21pdW0vaS50ZXN0KGMpKSYmL21hYyA/T1MvaS50ZXN0KGIucGxhdGZvcm0pJiZhd2FpdCBiLmdldEhpZ2hFbnRyb3B5VmFsdWVzKFtcImFyY2hpdGVjdHVyZVwiLFwicGxhdGZvcm1WZXJzaW9uXCJdKS50aGVuKCh7YXJjaGl0ZWN0dXJlOmMscGxhdGZvcm1WZXJzaW9uOmR9KT0+L2FybS9pLnRlc3QoY3x8XCJhcm1cIikmJjEzPD1wYXJzZUludChkfHxcIjEzXCIpKS5jYXRjaCgoKT0+ITApP2EoKTpuZXcgQmFyY29kZURldGVjdG9yKHtmb3JtYXRzOltcInFyX2NvZGVcIl19KX1fb25QbGF5KCl7dGhpcy5fc2NhblJlZ2lvbj10aGlzLl9jYWxjdWxhdGVTY2FuUmVnaW9uKHRoaXMuJHZpZGVvKTt0aGlzLl91cGRhdGVPdmVybGF5KCk7dGhpcy4kb3ZlcmxheSYmKHRoaXMuJG92ZXJsYXkuc3R5bGUuZGlzcGxheT1cIlwiKTt0aGlzLl9zY2FuRnJhbWUoKX1fb25Mb2FkZWRNZXRhRGF0YSgpe3RoaXMuX3NjYW5SZWdpb249dGhpcy5fY2FsY3VsYXRlU2NhblJlZ2lvbih0aGlzLiR2aWRlbyk7XG50aGlzLl91cGRhdGVPdmVybGF5KCl9X29uVmlzaWJpbGl0eUNoYW5nZSgpe2RvY3VtZW50LmhpZGRlbj90aGlzLnBhdXNlKCk6dGhpcy5fYWN0aXZlJiZ0aGlzLnN0YXJ0KCl9X2NhbGN1bGF0ZVNjYW5SZWdpb24oYSl7bGV0IGI9TWF0aC5yb3VuZCgyLzMqTWF0aC5taW4oYS52aWRlb1dpZHRoLGEudmlkZW9IZWlnaHQpKTtyZXR1cm57eDpNYXRoLnJvdW5kKChhLnZpZGVvV2lkdGgtYikvMikseTpNYXRoLnJvdW5kKChhLnZpZGVvSGVpZ2h0LWIpLzIpLHdpZHRoOmIsaGVpZ2h0OmIsZG93blNjYWxlZFdpZHRoOnRoaXMuX2xlZ2FjeUNhbnZhc1NpemUsZG93blNjYWxlZEhlaWdodDp0aGlzLl9sZWdhY3lDYW52YXNTaXplfX1fdXBkYXRlT3ZlcmxheSgpe3JlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+e2lmKHRoaXMuJG92ZXJsYXkpe3ZhciBhPXRoaXMuJHZpZGVvLGI9YS52aWRlb1dpZHRoLGM9YS52aWRlb0hlaWdodCxkPWEub2Zmc2V0V2lkdGgsZj1hLm9mZnNldEhlaWdodCxoPWEub2Zmc2V0TGVmdCxcbm09YS5vZmZzZXRUb3Asbj13aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShhKSxwPW4ub2JqZWN0Rml0LGs9Yi9jLHE9ZC9mO3N3aXRjaChwKXtjYXNlIFwibm9uZVwiOnZhciBnPWI7dmFyIGw9YzticmVhaztjYXNlIFwiZmlsbFwiOmc9ZDtsPWY7YnJlYWs7ZGVmYXVsdDooXCJjb3ZlclwiPT09cD9rPnE6azxxKT8obD1mLGc9bCprKTooZz1kLGw9Zy9rKSxcInNjYWxlLWRvd25cIj09PXAmJihnPU1hdGgubWluKGcsYiksbD1NYXRoLm1pbihsLGMpKX12YXIgW3Ysd109bi5vYmplY3RQb3NpdGlvbi5zcGxpdChcIiBcIikubWFwKChyLHkpPT57Y29uc3QgeD1wYXJzZUZsb2F0KHIpO3JldHVybiByLmVuZHNXaXRoKFwiJVwiKT8oeT9mLWw6ZC1nKSp4LzEwMDp4fSk7bj10aGlzLl9zY2FuUmVnaW9uLndpZHRofHxiO3E9dGhpcy5fc2NhblJlZ2lvbi5oZWlnaHR8fGM7cD10aGlzLl9zY2FuUmVnaW9uLnh8fDA7dmFyIHU9dGhpcy5fc2NhblJlZ2lvbi55fHwwO2s9dGhpcy4kb3ZlcmxheS5zdHlsZTtrLndpZHRoPVxuYCR7bi9iKmd9cHhgO2suaGVpZ2h0PWAke3EvYypsfXB4YDtrLnRvcD1gJHttK3crdS9jKmx9cHhgO2M9L3NjYWxlWFxcKC0xXFwpLy50ZXN0KGEuc3R5bGUudHJhbnNmb3JtKTtrLmxlZnQ9YCR7aCsoYz9kLXYtZzp2KSsoYz9iLXAtbjpwKS9iKmd9cHhgO2sudHJhbnNmb3JtPWEuc3R5bGUudHJhbnNmb3JtfX0pfXN0YXRpYyBfY29udmVydFBvaW50cyhhLGIpe2lmKCFiKXJldHVybiBhO2xldCBjPWIueHx8MCxkPWIueXx8MCxmPWIud2lkdGgmJmIuZG93blNjYWxlZFdpZHRoP2Iud2lkdGgvYi5kb3duU2NhbGVkV2lkdGg6MTtiPWIuaGVpZ2h0JiZiLmRvd25TY2FsZWRIZWlnaHQ/Yi5oZWlnaHQvYi5kb3duU2NhbGVkSGVpZ2h0OjE7Zm9yKGxldCBoIG9mIGEpaC54PWgueCpmK2MsaC55PWgueSpiK2Q7cmV0dXJuIGF9X3NjYW5GcmFtZSgpeyF0aGlzLl9hY3RpdmV8fHRoaXMuJHZpZGVvLnBhdXNlZHx8dGhpcy4kdmlkZW8uZW5kZWR8fChcInJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2tcImluXG50aGlzLiR2aWRlbz90aGlzLiR2aWRlby5yZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrLmJpbmQodGhpcy4kdmlkZW8pOnJlcXVlc3RBbmltYXRpb25GcmFtZSkoYXN5bmMoKT0+e2lmKCEoMT49dGhpcy4kdmlkZW8ucmVhZHlTdGF0ZSkpe3ZhciBhPURhdGUubm93KCktdGhpcy5fbGFzdFNjYW5UaW1lc3RhbXAsYj0xRTMvdGhpcy5fbWF4U2NhbnNQZXJTZWNvbmQ7YTxiJiZhd2FpdCBuZXcgUHJvbWlzZShkPT5zZXRUaW1lb3V0KGQsYi1hKSk7dGhpcy5fbGFzdFNjYW5UaW1lc3RhbXA9RGF0ZS5ub3coKTt0cnl7dmFyIGM9YXdhaXQgZS5zY2FuSW1hZ2UodGhpcy4kdmlkZW8se3NjYW5SZWdpb246dGhpcy5fc2NhblJlZ2lvbixxckVuZ2luZTp0aGlzLl9xckVuZ2luZVByb21pc2UsY2FudmFzOnRoaXMuJGNhbnZhc30pfWNhdGNoKGQpe2lmKCF0aGlzLl9hY3RpdmUpcmV0dXJuO3RoaXMuX29uRGVjb2RlRXJyb3IoZCl9IWUuX2Rpc2FibGVCYXJjb2RlRGV0ZWN0b3J8fGF3YWl0IHRoaXMuX3FyRW5naW5lUHJvbWlzZSBpbnN0YW5jZW9mXG5Xb3JrZXJ8fCh0aGlzLl9xckVuZ2luZVByb21pc2U9ZS5jcmVhdGVRckVuZ2luZSgpKTtjPyh0aGlzLl9vbkRlY29kZT90aGlzLl9vbkRlY29kZShjKTp0aGlzLl9sZWdhY3lPbkRlY29kZSYmdGhpcy5fbGVnYWN5T25EZWNvZGUoYy5kYXRhKSx0aGlzLiRjb2RlT3V0bGluZUhpZ2hsaWdodCYmKGNsZWFyVGltZW91dCh0aGlzLl9jb2RlT3V0bGluZUhpZ2hsaWdodFJlbW92YWxUaW1lb3V0KSx0aGlzLl9jb2RlT3V0bGluZUhpZ2hsaWdodFJlbW92YWxUaW1lb3V0PXZvaWQgMCx0aGlzLiRjb2RlT3V0bGluZUhpZ2hsaWdodC5zZXRBdHRyaWJ1dGUoXCJ2aWV3Qm94XCIsYCR7dGhpcy5fc2NhblJlZ2lvbi54fHwwfSBgK2Ake3RoaXMuX3NjYW5SZWdpb24ueXx8MH0gYCtgJHt0aGlzLl9zY2FuUmVnaW9uLndpZHRofHx0aGlzLiR2aWRlby52aWRlb1dpZHRofSBgK2Ake3RoaXMuX3NjYW5SZWdpb24uaGVpZ2h0fHx0aGlzLiR2aWRlby52aWRlb0hlaWdodH1gKSx0aGlzLiRjb2RlT3V0bGluZUhpZ2hsaWdodC5maXJzdEVsZW1lbnRDaGlsZC5zZXRBdHRyaWJ1dGUoXCJwb2ludHNcIixcbmMuY29ybmVyUG9pbnRzLm1hcCgoe3g6ZCx5OmZ9KT0+YCR7ZH0sJHtmfWApLmpvaW4oXCIgXCIpKSx0aGlzLiRjb2RlT3V0bGluZUhpZ2hsaWdodC5zdHlsZS5kaXNwbGF5PVwiXCIpKTp0aGlzLiRjb2RlT3V0bGluZUhpZ2hsaWdodCYmIXRoaXMuX2NvZGVPdXRsaW5lSGlnaGxpZ2h0UmVtb3ZhbFRpbWVvdXQmJih0aGlzLl9jb2RlT3V0bGluZUhpZ2hsaWdodFJlbW92YWxUaW1lb3V0PXNldFRpbWVvdXQoKCk9PnRoaXMuJGNvZGVPdXRsaW5lSGlnaGxpZ2h0LnN0eWxlLmRpc3BsYXk9XCJub25lXCIsMTAwKSl9dGhpcy5fc2NhbkZyYW1lKCl9KX1fb25EZWNvZGVFcnJvcihhKXthIT09ZS5OT19RUl9DT0RFX0ZPVU5EJiZjb25zb2xlLmxvZyhhKX1hc3luYyBfZ2V0Q2FtZXJhU3RyZWFtKCl7aWYoIW5hdmlnYXRvci5tZWRpYURldmljZXMpdGhyb3dcIkNhbWVyYSBub3QgZm91bmQuXCI7bGV0IGE9L14oZW52aXJvbm1lbnR8dXNlcikkLy50ZXN0KHRoaXMuX3ByZWZlcnJlZENhbWVyYSk/XCJmYWNpbmdNb2RlXCI6XG5cImRldmljZUlkXCIsYj1be3dpZHRoOnttaW46MTAyNH19LHt3aWR0aDp7bWluOjc2OH19LHt9XSxjPWIubWFwKGQ9Pk9iamVjdC5hc3NpZ24oe30sZCx7W2FdOntleGFjdDp0aGlzLl9wcmVmZXJyZWRDYW1lcmF9fSkpO2ZvcihsZXQgZCBvZlsuLi5jLC4uLmJdKXRyeXtsZXQgZj1hd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7dmlkZW86ZCxhdWRpbzohMX0pLGg9dGhpcy5fZ2V0RmFjaW5nTW9kZShmKXx8KGQuZmFjaW5nTW9kZT90aGlzLl9wcmVmZXJyZWRDYW1lcmE6XCJlbnZpcm9ubWVudFwiPT09dGhpcy5fcHJlZmVycmVkQ2FtZXJhP1widXNlclwiOlwiZW52aXJvbm1lbnRcIik7cmV0dXJue3N0cmVhbTpmLGZhY2luZ01vZGU6aH19Y2F0Y2goZil7fXRocm93XCJDYW1lcmEgbm90IGZvdW5kLlwiO31hc3luYyBfcmVzdGFydFZpZGVvU3RyZWFtKCl7bGV0IGE9dGhpcy5fcGF1c2VkO2F3YWl0IHRoaXMucGF1c2UoITApJiYhYSYmdGhpcy5fYWN0aXZlJiZhd2FpdCB0aGlzLnN0YXJ0KCl9c3RhdGljIF9zdG9wVmlkZW9TdHJlYW0oYSl7Zm9yKGxldCBiIG9mIGEuZ2V0VHJhY2tzKCkpYi5zdG9wKCksXG5hLnJlbW92ZVRyYWNrKGIpfV9zZXRWaWRlb01pcnJvcihhKXt0aGlzLiR2aWRlby5zdHlsZS50cmFuc2Zvcm09XCJzY2FsZVgoXCIrKFwidXNlclwiPT09YT8tMToxKStcIilcIn1fZ2V0RmFjaW5nTW9kZShhKXtyZXR1cm4oYT1hLmdldFZpZGVvVHJhY2tzKClbMF0pPy9yZWFyfGJhY2t8ZW52aXJvbm1lbnQvaS50ZXN0KGEubGFiZWwpP1wiZW52aXJvbm1lbnRcIjovZnJvbnR8dXNlcnxmYWNlL2kudGVzdChhLmxhYmVsKT9cInVzZXJcIjpudWxsOm51bGx9c3RhdGljIF9kcmF3VG9DYW52YXMoYSxiLGMsZD0hMSl7Yz1jfHxkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO2xldCBmPWImJmIueD9iLng6MCxoPWImJmIueT9iLnk6MCxtPWImJmIud2lkdGg/Yi53aWR0aDphLnZpZGVvV2lkdGh8fGEud2lkdGgsbj1iJiZiLmhlaWdodD9iLmhlaWdodDphLnZpZGVvSGVpZ2h0fHxhLmhlaWdodDtkfHwoZD1iJiZiLmRvd25TY2FsZWRXaWR0aD9iLmRvd25TY2FsZWRXaWR0aDptLGI9YiYmYi5kb3duU2NhbGVkSGVpZ2h0P1xuYi5kb3duU2NhbGVkSGVpZ2h0Om4sYy53aWR0aCE9PWQmJihjLndpZHRoPWQpLGMuaGVpZ2h0IT09YiYmKGMuaGVpZ2h0PWIpKTtiPWMuZ2V0Q29udGV4dChcIjJkXCIse2FscGhhOiExfSk7Yi5pbWFnZVNtb290aGluZ0VuYWJsZWQ9ITE7Yi5kcmF3SW1hZ2UoYSxmLGgsbSxuLDAsMCxjLndpZHRoLGMuaGVpZ2h0KTtyZXR1cm5bYyxiXX1zdGF0aWMgYXN5bmMgX2xvYWRJbWFnZShhKXtpZihhIGluc3RhbmNlb2YgSW1hZ2UpcmV0dXJuIGF3YWl0IGUuX2F3YWl0SW1hZ2VMb2FkKGEpLGE7aWYoYSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnR8fGEgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudHx8YSBpbnN0YW5jZW9mIFNWR0ltYWdlRWxlbWVudHx8XCJPZmZzY3JlZW5DYW52YXNcImluIHdpbmRvdyYmYSBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhc3x8XCJJbWFnZUJpdG1hcFwiaW4gd2luZG93JiZhIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXApcmV0dXJuIGE7aWYoYSBpbnN0YW5jZW9mXG5GaWxlfHxhIGluc3RhbmNlb2YgQmxvYnx8YSBpbnN0YW5jZW9mIFVSTHx8XCJzdHJpbmdcIj09PXR5cGVvZiBhKXtsZXQgYj1uZXcgSW1hZ2U7Yi5zcmM9YSBpbnN0YW5jZW9mIEZpbGV8fGEgaW5zdGFuY2VvZiBCbG9iP1VSTC5jcmVhdGVPYmplY3RVUkwoYSk6YS50b1N0cmluZygpO3RyeXtyZXR1cm4gYXdhaXQgZS5fYXdhaXRJbWFnZUxvYWQoYiksYn1maW5hbGx5eyhhIGluc3RhbmNlb2YgRmlsZXx8YSBpbnN0YW5jZW9mIEJsb2IpJiZVUkwucmV2b2tlT2JqZWN0VVJMKGIuc3JjKX19ZWxzZSB0aHJvd1wiVW5zdXBwb3J0ZWQgaW1hZ2UgdHlwZS5cIjt9c3RhdGljIGFzeW5jIF9hd2FpdEltYWdlTG9hZChhKXthLmNvbXBsZXRlJiYwIT09YS5uYXR1cmFsV2lkdGh8fGF3YWl0IG5ldyBQcm9taXNlKChiLGMpPT57bGV0IGQ9Zj0+e2EucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIixkKTthLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLGQpO2YgaW5zdGFuY2VvZiBFcnJvckV2ZW50P1xuYyhcIkltYWdlIGxvYWQgZXJyb3JcIik6YigpfTthLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsZCk7YS5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIixkKX0pfXN0YXRpYyBhc3luYyBfcG9zdFdvcmtlck1lc3NhZ2UoYSxiLGMsZCl7cmV0dXJuIGUuX3Bvc3RXb3JrZXJNZXNzYWdlU3luYyhhd2FpdCBhLGIsYyxkKX1zdGF0aWMgX3Bvc3RXb3JrZXJNZXNzYWdlU3luYyhhLGIsYyxkKXtpZighKGEgaW5zdGFuY2VvZiBXb3JrZXIpKXJldHVybi0xO2xldCBmPWUuX3dvcmtlck1lc3NhZ2VJZCsrO2EucG9zdE1lc3NhZ2Uoe2lkOmYsdHlwZTpiLGRhdGE6Y30sZCk7cmV0dXJuIGZ9fWUuREVGQVVMVF9DQU5WQVNfU0laRT00MDA7ZS5OT19RUl9DT0RFX0ZPVU5EPVwiTm8gUVIgY29kZSBmb3VuZFwiO2UuX2Rpc2FibGVCYXJjb2RlRGV0ZWN0b3I9ITE7ZS5fd29ya2VyTWVzc2FnZUlkPTA7ZXhwb3J0IGRlZmF1bHQgZVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXItc2Nhbm5lci5taW4uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/qr-scanner/qr-scanner.min.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames not based on template
/******/ 			if (chunkId === "node_modules_qr-scanner_qr-scanner-worker_min_js") return "js/" + chunkId + ".js";
/******/ 			// return url for filenames based on template
/******/ 			return undefined;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get mini-css chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference all chunks
/******/ 		__webpack_require__.miniCssF = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return undefined;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		// data-webpack is not used as build has no uniqueName
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			};
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "/";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"/js/qr-scanner": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						} else installedChunks[chunkId] = 0;
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk"] = self["webpackChunk"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./resources/js/qr-scanner.js");
/******/ 	
/******/ })()
;